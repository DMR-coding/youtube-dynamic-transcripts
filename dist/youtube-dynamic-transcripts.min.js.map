{"version":3,"sources":["webpack://youtube-dynamic-transcripts/webpack/bootstrap","webpack://youtube-dynamic-transcripts/webpack/runtime/global","webpack://youtube-dynamic-transcripts/webpack/runtime/publicPath","webpack://youtube-dynamic-transcripts/./src/utility.ts","webpack://youtube-dynamic-transcripts/./src/Caption.ts","webpack://youtube-dynamic-transcripts/./src/Transcript.ts","webpack://youtube-dynamic-transcripts/./src/index.ts","webpack://youtube-dynamic-transcripts/./src/index.scss"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","length","Error","replace","p","toggleClass","node","className","force","exists","indexOf","shouldExist","classNames","separator","split","filter","c","join","stringFilter","Caption","start","end","text","domElement","createElement","innerHTML","OPEN_ME","Transcript","videoID","lang","transcriptName","getPlayer","captionsURL","url","Promise","resolve","reject","xhr","XMLHttpRequest","open","responseType","onload","response","onerror","status","send","get","then","captionsLoaded","catch","captionsFailed","captionBox","textContent","captions","xmlCaptions","i","getAttribute","caption","addEventListener","seekToIndex","push","append","scrollTop","player","seekTo","event","console","log","data","YT","PlayerState","PLAYING","started","stopped","highlightCurrentCaption","removeCurrentHighlight","clearTimeout","element","rect","parentRect","currentTime","getCurrentTime","currentCaption","find","getBoundingClientRect","parentElement","top","bottom","setTimeout","offset","offsetTop","waitForNextCaption","nextCaption","secondsUntil","captionTimeout","container","toggler","toggle","playerElement","after","getElementById","ReferenceError","appendContainer","loadCaptions","Player","videoId","events","onStateChange","pendingInits","transcripts","ytdt","init","name","oldOnYouTubeIframeAPIReady","onYouTubeIframeAPIReady","pending","apply","warn"],"mappings":"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","file":"youtube-dynamic-transcripts.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export function toggleClass(node: HTMLElement, className: string, force?: boolean) {\n  const exists = node.className.indexOf(className) >= 0;\n  const shouldExist = force == null ? !exists : force;\n\n  if ((exists && shouldExist) || (!exists && !shouldExist)) {\n    return;\n  }\n\n  if (shouldExist) {\n    node.className += ` ${className}`;\n  } else {\n    node.className = stringFilter(node.className, className, ' ');\n  }\n}\n\nexport function stringFilter(classNames: string, className: string, separator: string): string {\n  return classNames\n    .split(separator)\n    .filter((c) => c !== className)\n    .join(separator);\n}\n\nexport function get(url: string): Promise<Document> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'document';\n    xhr.onload = () => { resolve(xhr.response); };\n    xhr.onerror = () => { reject(xhr.status); };\n\n    xhr.send();\n  });\n}\n\nexport function isWithinParentViewport(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  const parentRect = element.parentElement.getBoundingClientRect();\n  return (\n    rect.top >= parentRect.top && rect.bottom <= parentRect.bottom\n  );\n}\n","export class Caption {\n  domElement: HTMLElement\n\n  public start: number;\n\n  public end: number;\n\n  constructor(\n    start: number,\n    end: number,\n    text: string,\n  ) {\n    this.end = end;\n    this.start = start;\n    this.domElement = document.createElement('a');\n    this.domElement.innerHTML = text;\n    this.domElement.className = 'caption';\n  }\n}\n","/// <reference types=\"@types/youtube\" />\n/* global YT */\nimport {\n  get, isWithinParentViewport, toggleClass,\n} from './utility';\nimport { Caption } from './Caption';\n\nconst LOADING = 'Loading transcript...';\nconst FAILED_LOAD = '⚠️ Could not load transcript.';\n\nconst OPEN_ME = 'Open Transcript';\nconst CLOSE_ME = 'Close Transcript';\n\nconst TRANSCRIPT_URL = 'https://video.google.com/timedtext?v=';\n\nexport class Transcript {\n  private player: YT.Player;\n\n  private playerElement: HTMLElement\n\n  private captionTimeout?: number;\n\n  private currentCaption?: Caption;\n\n  private captions: Caption[] = [];\n\n  private videoID: string;\n\n  private captionBox: HTMLElement;\n\n  private toggler: HTMLElement;\n\n  private container: HTMLElement;\n\n  constructor(\n    videoID: string, lang: string, transcriptName: string, getPlayer?: () => HTMLElement,\n  ) {\n    this.videoID = videoID;\n\n    if (getPlayer) {\n      this.playerElement = getPlayer();\n    } else {\n      this.playerElement = document.getElementById(this.videoID);\n    }\n\n    if (!this.playerElement) {\n      throw new ReferenceError(\"Couldn't locate video embed frame.\");\n    }\n\n    let url = TRANSCRIPT_URL + videoID;\n\n    if (lang) {\n      url += `&lang=${lang}`;\n    }\n\n    if (transcriptName) {\n      url += `&name=${transcriptName}`;\n    }\n\n    this.appendContainer();\n    this.loadCaptions(url);\n\n    this.player = new YT.Player(videoID, {\n      videoId: videoID,\n      events: { onStateChange: this.onStateChange },\n    });\n  }\n\n  loadCaptions = (captionsURL: string) => {\n    get(captionsURL).then(this.captionsLoaded).catch(this.captionsFailed);\n\n    this.captionBox.textContent = LOADING;\n  }\n\n  captionsLoaded = (captions: Document) => {\n    const xmlCaptions = captions.getElementsByTagName('text');\n\n    this.captionBox.textContent = '';\n\n    for (let i = 0; i < xmlCaptions.length; i += 1) {\n      const start: number = +xmlCaptions[i].getAttribute('start');\n      const end: number = +xmlCaptions[i].getAttribute('dur') + start;\n      const caption = new Caption(start, end, xmlCaptions[i].textContent);\n\n      caption.domElement.addEventListener('click', () => {\n        this.seekToIndex(i);\n      });\n\n      this.captions.push(caption);\n      this.captionBox.append(caption.domElement);\n      this.captionBox.scrollTop = 0;\n    }\n  }\n\n  seekToIndex = (i: number) => {\n    const caption = this.captions[i];\n\n    this.player.seekTo(caption.start, true);\n  }\n\n  captionsFailed = () => {\n    this.captionBox.textContent = FAILED_LOAD;\n  }\n\n  onStateChange = (event: YT.OnStateChangeEvent) => {\n    console.log(event);\n    if (event.data === YT.PlayerState.PLAYING) {\n      this.started();\n    } else {\n      this.stopped();\n    }\n  }\n\n  started = () => {\n    this.highlightCurrentCaption();\n  }\n\n  stopped = () => {\n    this.removeCurrentHighlight();\n    this.clearTimeout();\n  }\n\n  highlightCurrentCaption = () => {\n    this.removeCurrentHighlight();\n\n    const currentTime = this.player.getCurrentTime();\n    this.currentCaption = this.captions.find(\n      (caption) => caption.start <= currentTime && caption.end > currentTime,\n    );\n\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', true);\n\n      if (!isWithinParentViewport(this.currentCaption.domElement)) {\n        // Defer this so that it'll take effect after the page gets updated with the highlight class\n        setTimeout(() => {\n          const offset = this.currentCaption.domElement.offsetTop;\n          this.captionBox.scrollTop = offset;\n        }, 0);\n      }\n    }\n\n    this.waitForNextCaption();\n  }\n\n  waitForNextCaption = () => {\n    this.clearTimeout();\n    const currentTime = this.player.getCurrentTime();\n    const nextCaption = this.captions.find((caption) => caption.start > currentTime);\n\n    if (nextCaption) {\n      const secondsUntil = nextCaption.start - currentTime;\n      this.captionTimeout = setTimeout(this.highlightCurrentCaption, secondsUntil * 1000);\n    }\n  }\n\n  private clearTimeout = () => {\n    if (this.captionTimeout) {\n      clearTimeout(this.captionTimeout);\n    }\n    this.captionTimeout = null;\n  }\n\n  appendContainer= () => {\n    this.container = document.createElement('div');\n    this.container.className = 'ytdt';\n\n    this.toggler = document.createElement('button');\n    this.toggler.className = 'toggle closed';\n    this.toggler.addEventListener('click', this.toggle);\n    this.toggler.textContent = OPEN_ME;\n    this.container.append(this.toggler);\n\n    this.captionBox = document.createElement('div');\n    this.captionBox.className = 'captions closed';\n    this.container.append(this.captionBox);\n\n    this.playerElement.after(this.container);\n  }\n\n  toggle = () => {\n    toggleClass(this.toggler, 'closed');\n    toggleClass(this.toggler, 'open');\n\n    toggleClass(this.captionBox, 'closed');\n    toggleClass(this.captionBox, 'open');\n\n    if (this.toggler.className.indexOf('closed') > -1) {\n      this.toggler.textContent = OPEN_ME;\n    } else {\n      this.toggler.textContent = CLOSE_ME;\n    }\n  }\n\n  removeCurrentHighlight = () => {\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', false);\n      this.currentCaption = null;\n    }\n  }\n}\n","import { Transcript } from './Transcript';\n\nconst pendingInits: [string, string, string][] = [];\nconst transcripts: Transcript[] = [];\n\nconst ytdt = {\n  Transcript,\n  init: (videoId: string, lang: string, name:string, getPlayer?: () => HTMLElement) => {\n    if (window.YT && window.YT.Player) {\n      transcripts.push(new Transcript(videoId, lang, name, getPlayer));\n    } else {\n      pendingInits.push([videoId, lang, name]);\n    }\n  },\n};\n\ndeclare global {\n  export interface Window {\n    ytdt: typeof ytdt,\n    onYouTubeIframeAPIReady: () => void\n  }\n}\n\nconst oldOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady;\nwindow.onYouTubeIframeAPIReady = function () {\n  if (oldOnYouTubeIframeAPIReady) { oldOnYouTubeIframeAPIReady(); }\n\n  for (const pending of pendingInits) {\n    ytdt.init.apply(this, pending);\n  }\n};\n\nif (window.ytdt) {\n  console.warn('Namespace already exists; not registering youtube-dynamic-transcripts');\n} else {\n  window.ytdt = ytdt;\n}\n","export default __webpack_public_path__ + \"youtube-dynamic-transcripts.min.css\";"],"sourceRoot":""}