{"version":3,"sources":["webpack://youtube-dynamic-transcripts/webpack/bootstrap","webpack://youtube-dynamic-transcripts/webpack/runtime/global","webpack://youtube-dynamic-transcripts/webpack/runtime/publicPath","webpack://youtube-dynamic-transcripts/./src/utility.ts","webpack://youtube-dynamic-transcripts/./src/Caption.ts","webpack://youtube-dynamic-transcripts/./src/Transcript.ts","webpack://youtube-dynamic-transcripts/./src/index.ts","webpack://youtube-dynamic-transcripts/./src/index.scss"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","length","Error","replace","p","toggleClass","node","className","force","exists","indexOf","shouldExist","classNames","separator","split","filter","c","join","stringFilter","Caption","start","end","text","domElement","createElement","textContent","OPEN_ME","Transcript","videoID","lang","transcriptName","captionsURL","url","Promise","resolve","reject","xhr","XMLHttpRequest","open","responseType","onload","response","onerror","status","send","get","then","captionsLoaded","catch","captionsFailed","captionBox","captions","xmlCaptions","i","getAttribute","caption","addEventListener","seekToIndex","push","append","scrollTo","player","seekTo","event","data","YT","PlayerState","PLAYING","started","stopped","highlightCurrentCaption","removeCurrentHighlight","clearTimeout","element","rect","parentRect","currentTime","getCurrentTime","currentCaption","find","getBoundingClientRect","parentElement","top","bottom","setTimeout","scrollIntoView","waitForNextCaption","nextCaption","secondsUntil","captionTimeout","container","toggler","toggle","getElementById","after","appendContainer","loadCaptions","Player","videoId","events","onStateChange","pendingInits","transcripts","ytdt","init","name","oldOnYouTubeIframeAPIReady","onYouTubeIframeAPIReady","pending","apply","console","warn"],"mappings":"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","file":"youtube-dynamic-transcripts.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export function toggleClass(node: HTMLElement, className: string, force?: boolean) {\n  const exists = node.className.indexOf(className) >= 0;\n  const shouldExist = force == null ? !exists : force;\n\n  if ((exists && shouldExist) || (!exists && !shouldExist)) {\n    return;\n  }\n\n  if (shouldExist) {\n    node.className += ` ${className}`;\n  } else {\n    node.className = stringFilter(node.className, className, ' ');\n  }\n}\n\nexport function stringFilter(classNames: string, className: string, separator: string): string {\n  return classNames\n    .split(separator)\n    .filter((c) => c !== className)\n    .join(separator);\n}\n\nexport function get(url: string): Promise<Document> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'document';\n    xhr.onload = () => { resolve(xhr.response); };\n    xhr.onerror = () => { reject(xhr.status); };\n\n    xhr.send();\n  });\n}\n\nexport function isWithinParentViewport(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  const parentRect = element.parentElement.getBoundingClientRect();\n  return (\n    rect.top >= parentRect.top && rect.bottom <= parentRect.bottom\n  );\n}\n","export class Caption {\n  domElement: HTMLElement\n\n  public start: number;\n\n  public end: number;\n\n  constructor(\n    start: number,\n    end: number,\n    text: string,\n  ) {\n    this.end = end;\n    this.start = start;\n    this.domElement = document.createElement('a');\n    this.domElement.textContent = text;\n    this.domElement.className = 'caption';\n  }\n}\n","/// <reference types=\"@types/youtube\" />\n/* global YT */\nimport {\n  get, isWithinParentViewport, toggleClass,\n} from './utility';\nimport { Caption } from './Caption';\n\nconst LOADING = 'Loading transcript...';\nconst FAILED_LOAD = '⚠️ Could not load transcript.';\n\nconst OPEN_ME = 'Open Transcript';\nconst CLOSE_ME = 'Close Transcript';\n\nconst TRANSCRIPT_URL = 'https://video.google.com/timedtext?v=';\n\nexport class Transcript {\n  private player: YT.Player;\n\n  private captionTimeout?: number;\n\n  private currentCaption?: Caption;\n\n  private captions: Caption[] = [];\n\n  private videoID: string;\n\n  private captionBox: HTMLElement;\n\n  private toggler: HTMLElement;\n\n  private container: HTMLElement;\n\n  constructor(videoID: string, lang: string, transcriptName: string) {\n    this.videoID = videoID;\n\n    let url = TRANSCRIPT_URL + videoID;\n\n    if (lang) {\n      url += `&lang=${lang}`;\n    }\n\n    if (transcriptName) {\n      url += `&name=${transcriptName}`;\n    }\n\n    this.appendContainer();\n    this.loadCaptions(url);\n\n    this.player = new YT.Player(videoID, {\n      videoId: videoID,\n      events: { onStateChange: this.onStateChange },\n    });\n  }\n\n  loadCaptions = (captionsURL: string) => {\n    get(captionsURL).then(this.captionsLoaded).catch(this.captionsFailed);\n\n    this.captionBox.textContent = LOADING;\n  }\n\n  captionsLoaded = (captions: Document) => {\n    const xmlCaptions = captions.getElementsByTagName('text');\n\n    this.captionBox.textContent = '';\n\n    for (let i = 0; i < xmlCaptions.length; i += 1) {\n      const start: number = +xmlCaptions[i].getAttribute('start');\n      const end: number = +xmlCaptions[i].getAttribute('dur') + start;\n      const caption = new Caption(start, end, xmlCaptions[i].textContent);\n\n      caption.domElement.addEventListener('click', () => {\n        this.seekToIndex(i);\n      });\n\n      this.captions.push(caption);\n      this.captionBox.append(caption.domElement);\n      this.captionBox.scrollTo(0, 0);\n    }\n  }\n\n  seekToIndex = (i: number) => {\n    const caption = this.captions[i];\n\n    this.player.seekTo(caption.start, true);\n  }\n\n  captionsFailed = () => {\n    this.captionBox.textContent = FAILED_LOAD;\n  }\n\n  onStateChange = (event: YT.OnStateChangeEvent) => {\n    if (event.data === YT.PlayerState.PLAYING) {\n      this.started();\n    } else {\n      this.stopped();\n    }\n  }\n\n  started = () => {\n    this.highlightCurrentCaption();\n  }\n\n  stopped = () => {\n    this.removeCurrentHighlight();\n    this.clearTimeout();\n  }\n\n  highlightCurrentCaption = () => {\n    this.removeCurrentHighlight();\n\n    const currentTime = this.player.getCurrentTime();\n    this.currentCaption = this.captions.find(\n      (caption) => caption.start <= currentTime && caption.end > currentTime,\n    );\n\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', true);\n\n      if (!isWithinParentViewport(this.currentCaption.domElement)) {\n        // Defer this so that it'll take effect after the page gets updated with the highlight class\n        setTimeout(() => {\n          this.currentCaption.domElement.scrollIntoView();\n        }, 0);\n      }\n    }\n\n    this.waitForNextCaption();\n  }\n\n  waitForNextCaption = () => {\n    this.clearTimeout();\n    const currentTime = this.player.getCurrentTime();\n    const nextCaption = this.captions.find((caption) => caption.start > currentTime);\n\n    if (nextCaption) {\n      const secondsUntil = nextCaption.start - currentTime;\n      this.captionTimeout = setTimeout(this.highlightCurrentCaption, secondsUntil * 1000);\n    }\n  }\n\n  private clearTimeout = () => {\n    if (this.captionTimeout) {\n      clearTimeout(this.captionTimeout);\n    }\n    this.captionTimeout = null;\n  }\n\n  appendContainer= () => {\n    this.container = document.createElement('div');\n    this.container.className = 'ytdt';\n\n    this.toggler = document.createElement('button');\n    this.toggler.className = 'toggle closed';\n    this.toggler.addEventListener('click', this.toggle);\n    this.toggler.textContent = OPEN_ME;\n    this.container.append(this.toggler);\n\n    this.captionBox = document.createElement('div');\n    this.captionBox.className = 'captions closed';\n    this.container.append(this.captionBox);\n\n    document.getElementById(this.videoID).after(this.container);\n  }\n\n  toggle = () => {\n    toggleClass(this.toggler, 'closed');\n    toggleClass(this.toggler, 'open');\n\n    toggleClass(this.captionBox, 'closed');\n    toggleClass(this.captionBox, 'open');\n\n    if (this.toggler.className.indexOf('closed') > -1) {\n      this.toggler.textContent = OPEN_ME;\n    } else {\n      this.toggler.textContent = CLOSE_ME;\n    }\n  }\n\n  removeCurrentHighlight = () => {\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', false);\n      this.currentCaption = null;\n    }\n  }\n}\n","import { Transcript } from './Transcript';\n\nconst pendingInits: [string, string, string][] = [];\nconst transcripts: Transcript[] = [];\n\nconst ytdt = {\n  Transcript,\n  init: (videoId: string, lang: string, name:string) => {\n    if (window.YT) {\n      transcripts.push(new Transcript(videoId, lang, name));\n    } else {\n      pendingInits.push([videoId, lang, name]);\n    }\n  },\n};\n\ndeclare global {\n  export interface Window {\n    ytdt: typeof ytdt,\n    onYouTubeIframeAPIReady: () => void\n  }\n}\n\nconst oldOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady;\nwindow.onYouTubeIframeAPIReady = function () {\n  if (oldOnYouTubeIframeAPIReady) { oldOnYouTubeIframeAPIReady(); }\n\n  for (const pending of pendingInits) {\n    ytdt.init.apply(this, pending);\n  }\n};\n\nif (window.ytdt) {\n  console.warn('Namespace already exists; not registering youtube-dynamic-transcripts');\n} else {\n  window.ytdt = ytdt;\n}\n","export default __webpack_public_path__ + \"youtube-dynamic-transcripts.min.css\";"],"sourceRoot":""}