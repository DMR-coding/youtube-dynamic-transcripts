{"version":3,"sources":["webpack://youtube-dynamic-transcripts/webpack/bootstrap","webpack://youtube-dynamic-transcripts/webpack/runtime/global","webpack://youtube-dynamic-transcripts/webpack/runtime/publicPath","webpack://youtube-dynamic-transcripts/./src/utility.ts","webpack://youtube-dynamic-transcripts/./src/Caption.ts","webpack://youtube-dynamic-transcripts/./src/Transcript.ts","webpack://youtube-dynamic-transcripts/./src/index.ts","webpack://youtube-dynamic-transcripts/./src/index.css"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","length","Error","replace","p","toggleClass","node","className","force","exists","indexOf","shouldExist","classNames","separator","split","filter","c","join","stringFilter","assertExists","val","TypeError","Caption","start","end","text","domElement","createElement","innerHTML","OPEN_ME","Transcript","videoID","lang","transcriptName","frameID","insertContainer","captionsURL","url","Promise","resolve","reject","xhr","XMLHttpRequest","open","responseType","onload","response","onerror","status","send","get","then","captionsLoaded","catch","captionsFailed","captionBox","textContent","captions","xmlCaptions","i","xmlCaption","getAttribute","caption","addEventListener","seekToIndex","push","append","console","warn","scrollTop","player","seekTo","event","data","YT","PlayerState","PLAYING","started","stopped","highlightCurrentCaption","removeCurrentHighlight","clearTimeout","currentTime","getCurrentTime","currentCaption","find","ensureCurrentCaptionVisible","waitForNextCaption","element","rect","parentRect","getBoundingClientRect","parentElement","top","bottom","setTimeout","deadspace","firstElementChild","offsetTop","nextCaption","secondsUntil","captionTimeout","container","toggler","toggle","el","getElementById","after","ReferenceError","generateContainer","insertAfterVideoFrame","loadCaptions","Player","videoId","events","onStateChange","pendingInits","transcripts","ytdt","init","args","oldOnYouTubeIframeAPIReady","onYouTubeIframeAPIReady","pending","apply"],"mappings":"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","file":"youtube-dynamic-transcripts.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export function toggleClass(node: HTMLElement, className: string, force?: boolean) {\n  const exists = node.className.indexOf(className) >= 0;\n  const shouldExist = force == null ? !exists : force;\n\n  if ((exists && shouldExist) || (!exists && !shouldExist)) {\n    return;\n  }\n\n  if (shouldExist) {\n    node.className += ` ${className}`;\n  } else {\n    node.className = stringFilter(node.className, className, ' ');\n  }\n}\n\nexport function stringFilter(classNames: string, className: string, separator: string): string {\n  return classNames\n    .split(separator)\n    .filter((c) => c !== className)\n    .join(separator);\n}\n\nexport function get(url: string): Promise<Document> {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'document';\n    xhr.onload = () => { resolve(xhr.response); };\n    xhr.onerror = () => { reject(xhr.status); };\n\n    xhr.send();\n  });\n}\n\nexport function isWithinParentViewport(element: HTMLElement) {\n  const rect = element.getBoundingClientRect();\n  const parentRect = assertExists(element.parentElement).getBoundingClientRect();\n  return (\n    rect.top >= parentRect.top && rect.bottom <= parentRect.bottom\n  );\n}\n\nexport function assertExists<T>(val: T | null | undefined): T {\n  if (val == null) {\n    throw new TypeError('Value may not be null.');\n  }\n  return val;\n}\n","export class Caption {\n  domElement: HTMLElement\n\n  public start: number;\n\n  public end: number;\n\n  constructor(\n    start: number,\n    end: number,\n    text: string,\n  ) {\n    this.end = end;\n    this.start = start;\n    this.domElement = document.createElement('a');\n    this.domElement.innerHTML = text;\n    this.domElement.className = 'caption';\n  }\n}\n","/// <reference types=\"@types/youtube\" />\n/* global YT */\nimport {\n  assertExists,\n  get, isWithinParentViewport, toggleClass,\n} from './utility';\nimport { Caption } from './Caption';\n\nconst LOADING = 'Loading transcript...';\nconst FAILED_LOAD = '⚠️ Could not load transcript.';\n\nconst OPEN_ME = 'Open Transcript';\nconst CLOSE_ME = 'Close Transcript';\n\nconst TRANSCRIPT_URL = 'https://video.google.com/timedtext?v=';\n\nexport class Transcript {\n  private player: YT.Player;\n\n  private captionTimeout: number | null = null;\n\n  private currentCaption: Caption | null | undefined = null;\n\n  private captions: Caption[] = [];\n\n  private videoID: string;\n\n  private captionBox: HTMLElement;\n\n  private toggler: HTMLElement;\n\n  private container: HTMLElement;\n\n  constructor(\n    videoID: string, lang: string, transcriptName?: string,\n    frameID?: string, // Defaults to same as videoID\n    insertContainer?: (container: HTMLElement) => void,\n  ) {\n    this.videoID = videoID;\n\n    let url = TRANSCRIPT_URL + videoID;\n\n    if (lang) {\n      url += `&lang=${lang}`;\n    }\n\n    if (transcriptName) {\n      url += `&name=${transcriptName}`;\n    }\n\n    this.generateContainer();\n    if (insertContainer) {\n      insertContainer(this.container);\n    } else {\n      this.insertAfterVideoFrame(this.container);\n    }\n\n    this.loadCaptions(url);\n\n    this.player = new YT.Player(\n      frameID || videoID, {\n        videoId: videoID,\n        events: { onStateChange: this.onStateChange },\n      },\n    );\n  }\n\n  loadCaptions = (captionsURL: string) => {\n    get(captionsURL).then(this.captionsLoaded).catch(this.captionsFailed);\n\n    this.captionBox.textContent = LOADING;\n  }\n\n  captionsLoaded = (captions: Document) => {\n    const xmlCaptions = captions.getElementsByTagName('text');\n\n    this.captionBox.textContent = '';\n\n    for (let i = 0; i < xmlCaptions.length; i += 1) {\n      const xmlCaption = xmlCaptions[i];\n\n      try {\n        const start: number = +assertExists(xmlCaption.getAttribute('start'));\n        const end: number = +assertExists(xmlCaption.getAttribute('dur')) + start;\n        const caption = new Caption(start, end, assertExists(xmlCaption.textContent));\n\n        caption.domElement.addEventListener('click', () => {\n          this.seekToIndex(i);\n        });\n\n        this.captions.push(caption);\n        this.captionBox.append(caption.domElement);\n      } catch (e) {\n        if (e instanceof TypeError) {\n          window.console?.warn('Found bad caption', xmlCaption);\n        }\n      }\n    }\n\n    this.captionBox.scrollTop = 0;\n  }\n\n  seekToIndex = (i: number) => {\n    const caption = this.captions[i];\n\n    this.player.seekTo(caption.start, true);\n  }\n\n  captionsFailed = () => {\n    this.captionBox.textContent = FAILED_LOAD;\n  }\n\n  onStateChange = (event: YT.OnStateChangeEvent) => {\n    if (event.data === YT.PlayerState.PLAYING) {\n      this.started();\n    } else {\n      this.stopped();\n    }\n  }\n\n  started = () => {\n    this.highlightCurrentCaption();\n  }\n\n  stopped = () => {\n    this.removeCurrentHighlight();\n    this.clearTimeout();\n  }\n\n  highlightCurrentCaption = () => {\n    this.removeCurrentHighlight();\n\n    const currentTime = this.player.getCurrentTime();\n    this.currentCaption = this.captions.find(\n      (caption) => caption.start <= currentTime && caption.end > currentTime,\n    );\n\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', true);\n      this.ensureCurrentCaptionVisible();\n    }\n\n    this.waitForNextCaption();\n  }\n\n  ensureCurrentCaptionVisible = () => {\n    if (!this.currentCaption) {\n      return;\n    }\n\n    if (!isWithinParentViewport(this.currentCaption.domElement)) {\n      // Defer this so that it'll take effect after the page gets updated with the highlight class\n      setTimeout(() => {\n        if (this.currentCaption) { // double check in case it changed during async\n          const deadspace = (this.captionBox.firstElementChild as HTMLElement).offsetTop;\n          this.captionBox.scrollTop = this.currentCaption.domElement.offsetTop - deadspace;\n        }\n      }, 0);\n    }\n  }\n\n  waitForNextCaption = () => {\n    this.clearTimeout();\n    const currentTime = this.player.getCurrentTime();\n    const nextCaption = this.captions.find((caption) => caption.start > currentTime);\n\n    if (nextCaption) {\n      const secondsUntil = nextCaption.start - currentTime;\n      this.captionTimeout = setTimeout(this.highlightCurrentCaption, secondsUntil * 1000);\n    }\n  }\n\n  private clearTimeout = () => {\n    if (this.captionTimeout) {\n      clearTimeout(this.captionTimeout);\n    }\n    this.captionTimeout = null;\n  }\n\n  generateContainer= () => {\n    this.container = document.createElement('div');\n    this.container.className = 'ytdt';\n\n    this.toggler = document.createElement('button');\n    this.toggler.className = 'toggle closed';\n    this.toggler.addEventListener('click', this.toggle);\n    this.toggler.textContent = OPEN_ME;\n    this.container.append(this.toggler);\n\n    this.captionBox = document.createElement('div');\n    this.captionBox.className = 'captions closed';\n    this.container.append(this.captionBox);\n  }\n\n  insertAfterVideoFrame = (el: HTMLElement) => {\n    try {\n      assertExists(document.getElementById(this.videoID)).after(el);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        throw new ReferenceError(\"Couldn't insert caption container by player ID.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  toggle = () => {\n    toggleClass(this.toggler, 'closed');\n    toggleClass(this.toggler, 'open');\n\n    toggleClass(this.captionBox, 'closed');\n    toggleClass(this.captionBox, 'open');\n\n    if (this.toggler.className.indexOf('closed') > -1) {\n      this.toggler.textContent = OPEN_ME;\n    } else {\n      this.toggler.textContent = CLOSE_ME;\n    }\n  }\n\n  removeCurrentHighlight = () => {\n    if (this.currentCaption) {\n      toggleClass(this.currentCaption.domElement, 'highlight', false);\n      this.currentCaption = null;\n    }\n  }\n}\n","import { Transcript } from './Transcript';\n\nconst pendingInits: ConstructorParameters<typeof Transcript>[] = [];\nconst transcripts: Transcript[] = [];\n\nconst ytdt = {\n  Transcript,\n  init: (...args: ConstructorParameters<typeof Transcript>) => {\n    if (window.YT && window.YT.Player) {\n      transcripts.push(new Transcript(...args));\n    } else {\n      pendingInits.push(args);\n    }\n  },\n};\n\ndeclare global {\n  export interface Window {\n    ytdt: typeof ytdt,\n    onYouTubeIframeAPIReady: () => void\n  }\n}\n\nconst oldOnYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady;\nwindow.onYouTubeIframeAPIReady = function () {\n  if (oldOnYouTubeIframeAPIReady) { oldOnYouTubeIframeAPIReady(); }\n\n  for (const pending of pendingInits) {\n    ytdt.init.apply(this, pending);\n  }\n};\n\nif (window.ytdt) {\n  console.warn('Namespace already exists; not registering youtube-dynamic-transcripts');\n} else {\n  window.ytdt = ytdt;\n}\n","export default __webpack_public_path__ + \"youtube-dynamic-transcripts.css\";"],"sourceRoot":""}